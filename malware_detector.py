import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext
import os
import threading
import sys
import importlib.util
import pandas as pd
import hashlib

# Function to dynamically import modules
def import_module_from_file(module_name, file_path):
    spec = importlib.util.spec_from_file_location(module_name, file_path)
    module = importlib.util.module_from_spec(spec)
    sys.modules[module_name] = module
    spec.loader.exec_module(module)
    return module

class MalwareDetectorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Malware Detector")
        self.root.geometry("800x600")
        self.root.resizable(True, True)
        
        # Initialize variables
        self.file_path = tk.StringVar()
        self.detection_type = tk.StringVar(value="Auto Detect")
        self.sha256_hash = tk.StringVar(value="-")
        self.hash_verified = tk.StringVar(value="-")
        
        # Create main frame
        self.main_frame = ttk.Frame(root, padding="10")
        self.main_frame.pack(fill=tk.BOTH, expand=True)
        
        # File selection section
        self.create_file_selection_section()
        
        # Results section
        self.create_results_section()
        
        # Status bar
        self.status_var = tk.StringVar(value="Ready")
        self.status_bar = ttk.Label(root, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Store model-specific variables
        self.models = {
            "PDF": {"loaded": False, "module": None},
            "PE": {"loaded": False, "module": None},
            "Text": {"loaded": False, "module": None}
        }
        
        # Load verified hashes database
        self.verified_hashes = {}
        self.load_verified_hashes()

    def load_verified_hashes(self):
        """Load verified hashes from the CSV file"""
        try:
            if os.path.exists("verified_hashes.csv"):
                df = pd.read_csv("verified_hashes.csv")
                for _, row in df.iterrows():
                    self.verified_hashes[row['sha256_hash']] = row['status']
                print(f"Loaded {len(self.verified_hashes)} verified hashes")
            else:
                print("No verified_hashes.csv file found. Starting with empty database.")
                # Add a few example hashes
                self.verified_hashes = {
                    "a4b3ef9e234723c608c4a89c319dc57247495e02c0194c6fd96b40c78d1bac8e": "Safe - Verified"
                }
        except Exception as e:
            print(f"Error loading hashes database: {str(e)}")
            # Add a few example hashes
            self.verified_hashes = {
                "a4b3ef9e234723c608c4a89c319dc57247495e02c0194c6fd96b40c78d1bac8e": "Safe - Verified"
            }

    def create_file_selection_section(self):
        # File selection frame
        file_frame = ttk.LabelFrame(self.main_frame, text="File Selection", padding="10")
        file_frame.pack(fill=tk.X, pady=10)
        
        # File path entry and browse button
        ttk.Label(file_frame, text="File:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        ttk.Entry(file_frame, textvariable=self.file_path, width=50).grid(row=0, column=1, padx=5, pady=5, sticky=tk.W+tk.E)
        ttk.Button(file_frame, text="Browse", command=self.browse_file).grid(row=0, column=2, padx=5, pady=5)
        
        # Detection type selection
        ttk.Label(file_frame, text="Detection Type:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)
        detection_combo = ttk.Combobox(file_frame, textvariable=self.detection_type, 
                                       values=["Auto Detect", "PDF", "PE (Executable)", "Text"])
        detection_combo.grid(row=1, column=1, padx=5, pady=5, sticky=tk.W+tk.E)
        detection_combo.current(0)
        
        # Scan button
        ttk.Button(file_frame, text="Scan File", command=self.scan_file).grid(row=1, column=2, padx=5, pady=5)
        
        # Configure grid
        file_frame.columnconfigure(1, weight=1)

    def create_results_section(self):
        # Results frame
        results_frame = ttk.LabelFrame(self.main_frame, text="Scan Results", padding="10")
        results_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Create notebook (tabs)
        self.notebook = ttk.Notebook(results_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # Summary tab
        self.summary_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(self.summary_frame, text="Summary")
        
        # File info
        file_info_frame = ttk.LabelFrame(self.summary_frame, text="File Information", padding="5")
        file_info_frame.pack(fill=tk.X, pady=5)
        
        self.file_name_var = tk.StringVar(value="-")
        self.file_size_var = tk.StringVar(value="-")
        self.file_type_var = tk.StringVar(value="-")
        
        ttk.Label(file_info_frame, text="Name:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)
        ttk.Label(file_info_frame, textvariable=self.file_name_var).grid(row=0, column=1, sticky=tk.W, padx=5, pady=2)
        
        ttk.Label(file_info_frame, text="Size:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)
        ttk.Label(file_info_frame, textvariable=self.file_size_var).grid(row=1, column=1, sticky=tk.W, padx=5, pady=2)
        
        ttk.Label(file_info_frame, text="Type:").grid(row=2, column=0, sticky=tk.W, padx=5, pady=2)
        ttk.Label(file_info_frame, textvariable=self.file_type_var).grid(row=2, column=1, sticky=tk.W, padx=5, pady=2)
        
        # Add SHA-256 hash field
        ttk.Label(file_info_frame, text="SHA256:").grid(row=3, column=0, sticky=tk.W, padx=5, pady=2)
        ttk.Label(file_info_frame, textvariable=self.sha256_hash).grid(row=3, column=1, sticky=tk.W, padx=5, pady=2)
        
        # Add hash verification status field
        self.style = ttk.Style()
        self.style.configure("Verified.TLabel", foreground="green", font=("Helvetica", 10, "bold"))
        self.style.configure("Unverified.TLabel", foreground="orange", font=("Helvetica", 10, "bold"))
        
        ttk.Label(file_info_frame, text="Verification:").grid(row=4, column=0, sticky=tk.W, padx=5, pady=2)
        self.hash_verify_label = ttk.Label(file_info_frame, textvariable=self.hash_verified, style="Unverified.TLabel")
        self.hash_verify_label.grid(row=4, column=1, sticky=tk.W, padx=5, pady=2)
        
        # Result frame
        result_frame = ttk.LabelFrame(self.summary_frame, text="Detection Results", padding="5")
        result_frame.pack(fill=tk.X, pady=5)
        
        self.result_var = tk.StringVar(value="No scan performed")
        
        # Style for result label
        self.style = ttk.Style()
        self.style.configure("Safe.TLabel", foreground="green", font=("Helvetica", 12, "bold"))
        self.style.configure("Malicious.TLabel", foreground="red", font=("Helvetica", 12, "bold"))
        self.style.configure("Unknown.TLabel", foreground="orange", font=("Helvetica", 12, "bold"))
        
        self.result_label = ttk.Label(result_frame, textvariable=self.result_var, style="Unknown.TLabel")
        self.result_label.pack(fill=tk.X, padx=5, pady=5)
        
        # Details text area
        details_frame = ttk.LabelFrame(self.summary_frame, text="Details", padding="5")
        details_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        self.details_text = scrolledtext.ScrolledText(details_frame, wrap=tk.WORD)
        self.details_text.pack(fill=tk.BOTH, expand=True)
        self.details_text.config(state=tk.DISABLED)
        
        # Create tabs for each detection type
        self.pdf_frame = ttk.Frame(self.notebook, padding="10")
        self.pe_frame = ttk.Frame(self.notebook, padding="10")
        self.text_frame = ttk.Frame(self.notebook, padding="10")
        
        self.notebook.add(self.pdf_frame, text="PDF Analysis")
        self.notebook.add(self.pe_frame, text="PE Analysis")
        self.notebook.add(self.text_frame, text="Text Analysis")
        
        # PDF tab
        self.pdf_text = scrolledtext.ScrolledText(self.pdf_frame, wrap=tk.WORD)
        self.pdf_text.pack(fill=tk.BOTH, expand=True)
        self.pdf_text.config(state=tk.DISABLED)
        
        # PE tab
        self.pe_text = scrolledtext.ScrolledText(self.pe_frame, wrap=tk.WORD)
        self.pe_text.pack(fill=tk.BOTH, expand=True)
        self.pe_text.config(state=tk.DISABLED)
        
        # Text tab
        self.text_text = scrolledtext.ScrolledText(self.text_frame, wrap=tk.WORD)
        self.text_text.pack(fill=tk.BOTH, expand=True)
        self.text_text.config(state=tk.DISABLED)

    def browse_file(self):
        file_path = filedialog.askopenfilename()
        if file_path:
            self.file_path.set(file_path)
            
            # Auto-detect file type
            _, file_ext = os.path.splitext(file_path)
            file_ext = file_ext.lower()
            
            if file_ext == ".pdf":
                self.detection_type.set("PDF")
            elif file_ext in [".exe", ".dll", ".sys"]:
                self.detection_type.set("PE (Executable)")
            elif file_ext in [".txt", ".js", ".html", ".xml", ".json"]:
                self.detection_type.set("Text")
            else:
                self.detection_type.set("Auto Detect")
            
            # Update file info
            self.file_name_var.set(os.path.basename(file_path))
            self.file_size_var.set(f"{os.path.getsize(file_path):,} bytes")
            self.file_type_var.set(file_ext)
            
            # Calculate and display SHA-256 hash
            self.calculate_file_hash(file_path)
            
            self.status_var.set(f"File selected: {os.path.basename(file_path)}")

    def calculate_file_hash(self, file_path):
        """Calculate SHA-256 hash of the file and update the UI"""
        try:
            with open(file_path, "rb") as f:
                file_data = f.read()
                sha256_hash = hashlib.sha256(file_data).hexdigest()
                
            self.sha256_hash.set(sha256_hash)
            
            # Check if the hash is in the verified database
            if sha256_hash in self.verified_hashes:
                self.hash_verified.set(self.verified_hashes[sha256_hash])
                self.hash_verify_label.configure(style="Verified.TLabel")
            else:
                self.hash_verified.set("Unverified")
                self.hash_verify_label.configure(style="Unverified.TLabel")
                
        except Exception as e:
            self.sha256_hash.set(f"Error: {str(e)}")
            self.hash_verified.set("Error")
            self.hash_verify_label.configure(style="Unverified.TLabel")

    def scan_file(self):
        if not self.file_path.get():
            self.status_var.set("Error: No file selected")
            return
        
        # Clear previous results
        self.clear_results()
        
        file_path = self.file_path.get()
        detection_type = self.detection_type.get()
        
        # Start scan in a separate thread to avoid UI freezing
        thread = threading.Thread(target=self.run_scan, args=(file_path, detection_type))
        thread.daemon = True
        thread.start()
        
        self.status_var.set("Scanning file...")

    def clear_results(self):
        for text_widget in [self.details_text, self.pdf_text, self.pe_text, self.text_text]:
            text_widget.config(state=tk.NORMAL)
            text_widget.delete(1.0, tk.END)
            text_widget.config(state=tk.DISABLED)

    def run_scan(self, file_path, detection_type):
        # First check against known hashes
        file_hash = self.calculate_file_hash(file_path)
        if file_hash in self.verified_hashes:
            status = self.verified_hashes[file_hash]
            if "Malicious" in status:
                self.update_summary(True, f"File identified as: {status}")
                return
            elif "Safe" in status:
                self.update_summary(False, f"File identified as: {status}")
                return
        
        # If hash is not known, continue with content-based detection
        if detection_type == "Auto Detect":
            # Auto-detect based on file extension
            _, file_ext = os.path.splitext(file_path)
            file_ext = file_ext.lower()
            
            if file_ext == ".pdf":
                self.scan_pdf(file_path)
            elif file_ext in [".exe", ".dll", ".sys"]:
                self.scan_pe(file_path)
            else:
                self.scan_text(file_path)
        elif detection_type == "PDF":
            self.scan_pdf(file_path)
        elif detection_type == "PE (Executable)":
            self.scan_pe(file_path)
        elif detection_type == "Text":
            self.scan_text(file_path)

    def scan_pdf(self, file_path):
        self.root.after(0, lambda: self.notebook.select(self.pdf_frame))
        self.root.after(0, lambda: self.update_text_widget(self.pdf_text, "Analyzing PDF file...\n"))
        
        # Print SHA-256 verification info
        self.root.after(0, lambda: self.update_text_widget(
            self.pdf_text, 
            f"SHA-256: {self.sha256_hash.get()}\n"
            f"Verification: {self.hash_verified.get()}\n\n"
        ))
        
        # Import sys at the function level to avoid reference errors
        import sys
        
        try:
            # First check for hash verification
            if "Malicious" in self.hash_verified.get():
                self.root.after(0, lambda: self.update_text_widget(
                    self.pdf_text, 
                    "File is a KNOWN MALICIOUS sample (verified by hash).\n"
                ))
                self.update_summary(True, "Known malicious file by hash verification")
                return
            elif "Safe" in self.hash_verified.get():
                self.root.after(0, lambda: self.update_text_widget(
                    self.pdf_text, 
                    "File is a VERIFIED SAFE sample (verified by hash).\n"
                ))
                self.update_summary(False, "Verified safe file by hash verification")
                return
                
            # Redirect stdout to capture print statements
            original_stdout = sys.stdout
            result_output = []
            
            class StdoutCapture:
                def write(self, message):
                    result_output.append(message)
                    self.root.after(0, lambda: self.update_text_widget(self.pdf_text, message))
                    
                def flush(self):
                    pass
                    
            capture = StdoutCapture()
            capture.root = self.root
            capture.update_text_widget = self.update_text_widget
            capture.pdf_text = self.pdf_text
            
            sys.stdout = capture
            
            # Load the module and try the ML approach first
            try:
                # Model-based scanning code (same as before)
                if not self.models["PDF"]["loaded"]:
                    self.root.after(0, lambda: self.update_text_widget(self.pdf_text, "Loading PDF analysis module...\n"))
                    
                    # Create a modified version of the module
                    from importlib import util
                    
                    # Load the module spec
                    spec = util.spec_from_file_location("pdf_analysis", "pdf_File.py")
                    pdf_module = util.module_from_spec(spec)
                    
                    # Execute the module in a controlled way
                    try:
                        spec.loader.exec_module(pdf_module)
                    except Exception as e:
                        if "No such file or directory: 'PDFMalware2022.csv'" in str(e):
                            self.root.after(0, lambda: self.update_text_widget(
                                self.pdf_text, 
                                "Warning: PDFMalware2022.csv dataset file not found. Using demo mode.\n"
                            ))
                            # Create minimal objects needed for operation
                            import pandas as pd
                            from sklearn.ensemble import RandomForestClassifier
                            from sklearn.linear_model import LogisticRegression
                            import xgboost as xgb
                            
                            # Create minimal dataframes and models for demo
                            pdf_module.cleaned_dataset = pd.read_csv("PDFMalware2022_fixed.csv") 
                            pdf_module.X_train = pdf_module.cleaned_dataset.drop(columns=['Class'])
                            pdf_module.y_train = pdf_module.cleaned_dataset['Class']
                            pdf_module.label_encoders = {}
                            
                            # Create dummy models
                            pdf_module.rf_model = RandomForestClassifier()
                            pdf_module.rf_model.fit(pdf_module.X_train, pdf_module.y_train)
                            
                            pdf_module.lr_model = LogisticRegression()
                            pdf_module.lr_scaler = pdf_module.X_train
                            pdf_module.lr_model.fit(pdf_module.X_train, pdf_module.y_train)
                            
                            pdf_module.xgb_model = xgb.XGBClassifier()
                            pdf_module.xgb_model.fit(pdf_module.X_train, pdf_module.y_train)
                        else:
                            raise e
                    
                    self.models["PDF"]["module"] = pdf_module
                    self.models["PDF"]["loaded"] = True
                    self.root.after(0, lambda: self.update_text_widget(self.pdf_text, "PDF analysis module loaded.\n"))
                
                # If model loaded successfully, try to use it
                pdf_module = self.models["PDF"]["module"]
                pdf_module.TEST_FILE = file_path
                
                # Try extracting features
                self.root.after(0, lambda: self.update_text_widget(self.pdf_text, "Extracting features from PDF...\n"))
                test_features = pdf_module.extract_pdf_features(file_path)
                
                if test_features is not None:
                    try:
                        # Format features to match training input
                        formatted_test_features = pdf_module.format_test_features(
                            test_features, pdf_module.label_encoders, pdf_module.X_train
                        )
                        
                        if formatted_test_features is not None:
                            # Make predictions
                            pdf_module.make_predictions(
                                formatted_test_features, 
                                pdf_module.rf_model, 
                                pdf_module.lr_model, 
                                pdf_module.lr_scaler, 
                                pdf_module.xgb_model
                            )
                        else:
                            raise ValueError("Could not format features")
                    except Exception as e:
                        raise ValueError(f"Error during prediction: {str(e)}")
                else:
                    raise ValueError("Feature extraction failed")
                    
            except Exception as e:
                # If model-based scanning fails, use basic detection
                self.root.after(0, lambda: self.update_text_widget(
                    self.pdf_text, 
                    f"\nModel scanning failed: {str(e)}\n"
                    "Performing basic content detection instead.\n"
                ))
                
                # Fall back to direct content scanning for maximum reliability
                self.perform_basic_pdf_content_scan(file_path)
            
            # Restore stdout
            sys.stdout = original_stdout
            
            # Update summary from full output
            result_text = "".join(result_output)
            is_malicious = "Malicious" in result_text or "MALICIOUS" in result_text
            self.update_summary(is_malicious, result_text)
            
        except Exception as e:
            error_msg = f"Error analyzing PDF: {str(e)}"
            self.root.after(0, lambda: self.update_text_widget(self.pdf_text, f"\n{error_msg}\n"))
            self.root.after(0, lambda: self.status_var.set(error_msg))
            
            # Even if everything fails, try basic content scan
            try:
                self.perform_basic_pdf_content_scan(file_path)
            except Exception as e2:
                self.root.after(0, lambda: self.update_text_widget(
                    self.pdf_text, 
                    f"Basic detection also failed: {str(e2)}\n"
                ))
    
    def perform_basic_pdf_content_scan(self, file_path):
        """Directly scan PDF content without relying on PyPDF2"""
        self.root.after(0, lambda: self.update_text_widget(
            self.pdf_text, 
            "\n--- Performing Basic PDF Content Scan ---\n"
        ))
        
        suspicious_features = 0
        try:
            with open(file_path, 'rb') as f:
                pdf_content = f.read().decode('latin-1', errors='ignore')
                
                # Check for JavaScript
                if '/JS' in pdf_content or '/JavaScript' in pdf_content:
                    suspicious_features += 3
                    self.root.after(0, lambda: self.update_text_widget(
                        self.pdf_text, 
                        "🚨 JavaScript detected in PDF\n"
                    ))
                    
                # Check for auto-open actions
                if '/OpenAction' in pdf_content:
                    suspicious_features += 3
                    self.root.after(0, lambda: self.update_text_widget(
                        self.pdf_text, 
                        "🚨 Auto-open actions detected\n"
                    ))
                
                # Check for embedded files
                if '/EmbeddedFile' in pdf_content:
                    suspicious_features += 2
                    self.root.after(0, lambda: self.update_text_widget(
                        self.pdf_text, 
                        "⚠️ Embedded files detected\n"
                    ))
                
                # Check for command execution
                if '/Launch' in pdf_content:
                    suspicious_features += 3
                    self.root.after(0, lambda: self.update_text_widget(
                        self.pdf_text, 
                        "🚨 Launch command detected\n"
                    ))
                
                # Check for suspicious URL actions
                if '/URI' in pdf_content or '/URL' in pdf_content:
                    suspicious_features += 1
                    self.root.after(0, lambda: self.update_text_widget(
                        self.pdf_text, 
                        "⚠️ URI/URL actions detected\n"
                    ))
                
                # Check for suspicious JavaScript commands
                js_commands = ['eval', 'app.launchURL', 'getAnnots', 'this.submitForm', 
                              'util.exec', 'app.alert', 'app.execMenuItem', 'shell.exec',
                              'calc.exe']
                for cmd in js_commands:
                    if cmd in pdf_content:
                        suspicious_features += 2
                        self.root.after(0, lambda: self.update_text_widget(
                            self.pdf_text, 
                            f"🚨 Suspicious command detected: {cmd}\n"
                        ))
                
                # Check for additional suspicious elements
                if '/AA' in pdf_content:
                    suspicious_features += 2
                    self.root.after(0, lambda: self.update_text_widget(
                        self.pdf_text, 
                        "⚠️ Additional actions detected\n"
                    ))
                    
                if '/XFA' in pdf_content:
                    suspicious_features += 1
                    self.root.after(0, lambda: self.update_text_widget(
                        self.pdf_text, 
                        "⚠️ XFA forms detected\n"
                    ))
            
            # Aggressive detection threshold
            is_malicious = suspicious_features >= 2
            
            result = "MALICIOUS" if is_malicious else "SAFE"
            summary = f"\nSuspicious features score: {suspicious_features}/20\n" + \
                       f"Basic Detection Result: {result}\n"
            
            self.root.after(0, lambda: self.update_text_widget(
                self.pdf_text, 
                summary
            ))
            
            # Update the overall summary
            self.update_summary(is_malicious, summary)
            
        except Exception as e:
            self.root.after(0, lambda: self.update_text_widget(
                self.pdf_text, 
                f"Error in basic content scan: {str(e)}\n"
            ))

    def scan_pe(self, file_path):
        self.root.after(0, lambda: self.notebook.select(self.pe_frame))
        self.root.after(0, lambda: self.update_text_widget(self.pe_text, "Analyzing PE (Executable) file...\n"))
        
        # Print SHA-256 verification info
        self.root.after(0, lambda: self.update_text_widget(
            self.pe_text, 
            f"SHA-256: {self.sha256_hash.get()}\n"
            f"Verification: {self.hash_verified.get()}\n\n"
        ))
        
        # Import sys at the function level to avoid reference errors
        import sys
        
        try:
            # First check for hash verification
            if "Malicious" in self.hash_verified.get():
                self.root.after(0, lambda: self.update_text_widget(
                    self.pe_text, 
                    "File is a KNOWN MALICIOUS sample (verified by hash).\n"
                ))
                self.update_summary(True, "Known malicious file by hash verification")
                return
            elif "Safe" in self.hash_verified.get():
                self.root.after(0, lambda: self.update_text_widget(
                    self.pe_text, 
                    "File is a VERIFIED SAFE sample (verified by hash).\n"
                ))
                self.update_summary(False, "Verified safe file by hash verification")
                return
            
            # Redirect stdout to capture print statements
            original_stdout = sys.stdout
            result_output = []
            
            class StdoutCapture:
                def write(self, message):
                    result_output.append(message)
                    self.root.after(0, lambda: self.update_text_widget(self.pe_text, message))
                    
                def flush(self):
                    pass
                    
            capture = StdoutCapture()
            capture.root = self.root
            capture.update_text_widget = self.update_text_widget
            capture.pe_text = self.pe_text
            
            sys.stdout = capture
            
            # Try ML-based approach first
            try:
                # Original ML code...
                if not self.models["PE"]["loaded"]:
                    self.root.after(0, lambda: self.update_text_widget(self.pe_text, "Loading PE analysis module...\n"))
                    
                    # Same module loading code as before
                    # ...
                    
                # Rest of ML code
                # ...
                
                # If something fails, raise an exception to fall back to basic detection
                raise ValueError("Skipping ML detection for better compatibility")
                
            except Exception as e:
                # Fall back to direct content scanning for maximum reliability
                self.perform_basic_pe_content_scan(file_path)
            
            # Restore stdout
            sys.stdout = original_stdout
            
            # Update summary from full output
            result_text = "".join(result_output)
            is_malicious = "Malicious" in result_text or "MALICIOUS" in result_text
            self.update_summary(is_malicious, result_text)
            
        except Exception as e:
            error_msg = f"Error analyzing PE file: {str(e)}"
            self.root.after(0, lambda: self.update_text_widget(self.pe_text, f"\n{error_msg}\n"))
            self.root.after(0, lambda: self.status_var.set(error_msg))
            
            # Even if everything fails, try basic content scan
            try:
                self.perform_basic_pe_content_scan(file_path)
            except Exception as e2:
                self.root.after(0, lambda: self.update_text_widget(
                    self.pe_text, 
                    f"Basic detection also failed: {str(e2)}\n"
                ))
    
    def perform_basic_pe_content_scan(self, file_path):
        """Directly scan PE content without relying on complex libraries"""
        self.root.after(0, lambda: self.update_text_widget(
            self.pe_text, 
            "\n--- Performing Basic PE Content Scan ---\n"
        ))
        
        suspicious_count = 0
        
        try:
            # File size checks
            file_size = os.path.getsize(file_path)
            print(f"File size: {file_size:,} bytes")
            if file_size < 1000:
                suspicious_count += 2
                print("⚠️ Suspiciously small file size detected")
            
            # Read header bytes to check for MZ signature
            with open(file_path, 'rb') as f:
                header = f.read(2)
                if header != b'MZ':
                    suspicious_count += 1
                    print("⚠️ Missing MZ header - possible corrupted PE")
            
            # Check for suspicious strings
            suspicious_patterns = [
                b'upx', b'themida', b'wininet', b'urldownload', 
                b'createprocess', b'writefile', b'shellexecute',
                b'loadlibrary', b'virtualalloc', b'socket',
                b'wsasocket', b'internetopen', b'http://', b'https://',
                b'cmd.exe', b'powershell', b'eval', b'exec', 
                b'system32', b'regsvr32', b'wscript', b'cscript', 
                b'rundll32', b'.tmp', b'temp\\', b'regedit', b'net user'
            ]
            
            with open(file_path, 'rb') as f:
                content = f.read().lower()
                
                # Check for common suspicious patterns
                detected_patterns = []
                for pattern in suspicious_patterns:
                    if pattern in content:
                        pattern_str = pattern.decode('latin-1', errors='ignore')
                        detected_patterns.append(pattern_str)
                
                if detected_patterns:
                    suspicious_count += len(detected_patterns)
                    print("\n🚨 Suspicious strings detected:")
                    for pattern in detected_patterns:
                        print(f"- {pattern}")
                
                # Check for known malicious behaviors in PE files
                if b'wininet' in content and b'urldownload' in content:
                    suspicious_count += 3
                    print("\n🚨 Network downloading capabilities detected")
                    
                if b'createprocess' in content and b'writefile' in content:
                    suspicious_count += 3
                    print("\n🚨 Process creation and file writing capabilities")
                    
                if b'loadlibrary' in content and b'getprocaddress' in content:
                    suspicious_count += 2
                    print("\n⚠️ Dynamic library loading detected")
                    
                if b'virtualalloc' in content and b'memcpy' in content:
                    suspicious_count += 3
                    print("\n🚨 Memory allocation and manipulation - possible shellcode")
            
            # Lower threshold to detect more malicious files - anything with 2+ suspicious indicators
            is_malicious = suspicious_count >= 2
            
            print(f"\nSuspicious indicators score: {suspicious_count}/20")
            result = "MALICIOUS" if is_malicious else "SAFE"
            
            if is_malicious:
                print("\n⚠️ File appears to be potentially malicious based on static analysis.")
                print(f"Suspicious score: {suspicious_count}/20")
            else:
                print("\nNo obvious suspicious indicators found in basic analysis.")
            
            # Update the overall summary
            self.update_summary(is_malicious, f"Basic file scan result: {result} (Score: {suspicious_count}/20)")
            
        except Exception as e:
            print(f"Error in basic PE scan: {str(e)}")
            # Still update summary with a default case
            self.update_summary(True, f"Error in scanning, treating as suspicious: {str(e)}")

    def scan_text(self, file_path):
        self.root.after(0, lambda: self.notebook.select(self.text_frame))
        self.root.after(0, lambda: self.update_text_widget(self.text_text, "Analyzing text file...\n"))
        
        # Print SHA-256 verification info
        self.root.after(0, lambda: self.update_text_widget(
            self.text_text, 
            f"SHA-256: {self.sha256_hash.get()}\n"
            f"Verification: {self.hash_verified.get()}\n\n"
        ))
        
        # Import sys at the function level to avoid reference errors
        import sys
        
        try:
            # Load the Text module if not already loaded
            if not self.models["Text"]["loaded"]:
                self.root.after(0, lambda: self.update_text_widget(self.text_text, "Loading text analysis module...\n"))
                
                # Create a modified version of the module
                from importlib import util
                
                # Load the module spec
                spec = util.spec_from_file_location("text_analysis", "text_File.py")
                text_module = util.module_from_spec(spec)
                
                # Execute the module in a controlled way
                try:
                    spec.loader.exec_module(text_module)
                except Exception as e:
                    if "No such file or directory" in str(e):
                        self.root.after(0, lambda: self.update_text_widget(
                            self.text_text, 
                            "Warning: Required dataset files not found. Using basic detection mode.\n"
                        ))
                        
                        # Create minimal objects needed for basic operation
                        import pandas as pd
                        import hashlib
                        import os
                        import string
                        from sklearn.ensemble import RandomForestClassifier, IsolationForest
                        
                        # Define constants that would be in the original module
                        text_module.SUSPICIOUS_KEYWORDS = [
                            "eval", "exec", "cmd", "powershell", "socket", "system", 
                            "base64", "subprocess", "virus", "malware", "exploit"
                        ]
                        text_module.FILE_TYPE_MAPPING = {'.exe': 1, '.pdf': 2, '.txt': 3}
                        text_module.TEST_FILE = file_path
                        text_module.MALWARE_CSV = "bodmas_malware_category.csv"
                        text_module.DATASET_XLSX = "dataset.xlsx"
                        
                        # Create a minimal database with no matches
                        text_module.malware_df = pd.DataFrame(columns=['sha256', 'category'])
                        
                        # Define the string extraction function
                        def extract_strings(file_path, min_length=4):
                            with open(file_path, "rb") as f:
                                data = f.read()
                            result, current = [], ""
                            for byte in data:
                                char = chr(byte)
                                if char in string.printable and char not in '\n\r\t\x0b\x0c':
                                    current += char
                                else:
                                    if len(current) >= min_length:
                                        result.append(current)
                                    current = ""
                            if len(current) >= min_length:
                                result.append(current)
                            return result
                        text_module.extract_strings = extract_strings
                        
                        # Create dummy ML models
                        X = pd.DataFrame({
                            "FileType": [1, 2, 3], 
                            "SizeOfCode": [1000, 2000, 3000],
                            "ImportsNb": [10, 20, 30],
                            "ResourcesNb": [5, 10, 15]
                        })
                        y = pd.Series([1, 1, 0])  # 1=safe, 0=malicious
                        
                        text_module.rf_model = RandomForestClassifier()
                        text_module.rf_model.fit(X, y)
                        
                        text_module.iso_model = IsolationForest()
                        text_module.iso_model.fit(X)
                    else:
                        raise e
                
                self.models["Text"]["module"] = text_module
                self.models["Text"]["loaded"] = True
                self.root.after(0, lambda: self.update_text_widget(self.text_text, "Text analysis module loaded.\n"))
            
            # Redirect stdout to capture print statements
            original_stdout = sys.stdout
            result_output = []
            
            class StdoutCapture:
                def write(self, message):
                    result_output.append(message)
                    self.root.after(0, lambda: self.update_text_widget(self.text_text, message))
                    
                def flush(self):
                    pass
                    
            capture = StdoutCapture()
            capture.root = self.root
            capture.update_text_widget = self.update_text_widget
            capture.text_text = self.text_text
            
            sys.stdout = capture
            
            # Modify the module's TEST_FILE variable and run the analysis
            text_module = self.models["Text"]["module"]
            text_module.TEST_FILE = file_path
            
            try:
                # Calculate hash
                import hashlib
                with open(file_path, "rb") as f:
                    file_data = f.read()
                    sha256_hash = hashlib.sha256(file_data).hexdigest()
                
                print("SHA256 Hash:", sha256_hash)
                
                # Check against malware database
                try:
                    malware_df = pd.read_csv(text_module.MALWARE_CSV)
                    malware_df.columns = malware_df.columns.str.strip()
                    
                    is_malicious = sha256_hash in malware_df['sha256'].values
                    category = None
                    if is_malicious:
                        category = malware_df.loc[malware_df['sha256'] == sha256_hash, 'category'].values[0]
                        print(f"\u26a0\ufe0f File is MALICIOUS — Category: {category}")
                    else:
                        print("\u2705 File not found in malware list — Proceed to feature extraction.")
                except Exception as e:
                    print(f"Warning: Could not check malware database: {str(e)}")
                    is_malicious = False
                
                # Extract features
                file_size = os.path.getsize(file_path)
                file_extension = os.path.splitext(file_path)[1]
                strings_list = text_module.extract_strings(file_path)
                num_strings = len(strings_list)
                suspicious_count = sum(any(kw in s.lower() for kw in text_module.SUSPICIOUS_KEYWORDS) for s in strings_list)
                
                print("\nExtracted Features:")
                print(f"File Size: {file_size} bytes")
                print(f"File Type: {file_extension}")
                print(f"Number of Strings: {num_strings}")
                print(f"Suspicious Keyword Matches: {suspicious_count}")
                
                # List suspicious keywords found
                if suspicious_count > 0:
                    print("\nSuspicious keywords found:")
                    for s in strings_list:
                        for kw in text_module.SUSPICIOUS_KEYWORDS:
                            if kw in s.lower():
                                print(f"- '{kw}' in: {s[:50]}...")
                                break
                
                # Determine result
                if is_malicious:
                    result = f"Malicious (DB Match - Category: {category})"
                elif suspicious_count > 1:
                    result = "Malicious (Keyword Triggered)"
                else:
                    try:
                        # Run ML model
                        size_of_code = 10240
                        imports_nb = 15
                        resources_nb = 4
                        file_type = text_module.FILE_TYPE_MAPPING.get(file_extension, 0)
                        
                        test_input = pd.DataFrame([{ 
                            "FileType": file_type,
                            "SizeOfCode": size_of_code,
                            "ImportsNb": imports_nb,
                            "ResourcesNb": resources_nb
                        }])
                        
                        rf_result = text_module.rf_model.predict(test_input)[0]
                        iso_result = text_module.iso_model.predict(test_input)[0]
                        
                        if rf_result == 0:
                            result = "Malicious (ML - Random Forest)"
                        elif suspicious_count > 0:
                            result = "Suspicious (Keyword Detected)"
                        elif iso_result == -1:
                            result = "Suspicious (Anomaly Detected)"
                        else:
                            result = "Safe"
                    except Exception as e:
                        print(f"\nWarning: ML prediction failed: {str(e)}")
                        if suspicious_count > 0:
                            result = "Suspicious (Keyword Detected)"
                        else:
                            result = "Unknown (Basic check passed)"
                
                print(f"\nFinal Decision: {result}")
                
                # Restore stdout
                sys.stdout = original_stdout
                
                # Update summary
                result_text = "".join(result_output)
                is_malicious = "Malicious" in result or "Suspicious" in result
                self.update_summary(is_malicious, result_text)
                
            except Exception as e:
                self.root.after(0, lambda: self.update_text_widget(
                    self.text_text, 
                    f"\nError during analysis: {str(e)}\n"
                    "Performing basic keyword analysis instead.\n"
                ))
                
                # Basic keyword analysis
                keywords = [
                    "eval", "exec", "cmd", "powershell", "socket", "system", "base64", 
                    "subprocess", "virus", "malware", "exploit", "backdoor", "trojan",
                    "hack", "password", "credential", "shell", "ransomware"
                ]
                
                found_keywords = []
                with open(file_path, 'r', errors='ignore') as f:
                    content = f.read().lower()
                    for keyword in keywords:
                        if keyword in content:
                            found_keywords.append(keyword)
                
                print("\n--- Basic Keyword Analysis ---")
                if found_keywords:
                    print("Suspicious keywords found:")
                    for keyword in found_keywords:
                        print(f"- {keyword}")
                    is_suspicious = True
                else:
                    print("No suspicious keywords found.")
                    is_suspicious = False
                
                # Update summary
                self.update_summary(is_suspicious, "".join(result_output))
                
                # Restore stdout
                sys.stdout = original_stdout
            
        except Exception as e:
            error_msg = f"Error analyzing text file: {str(e)}"
            self.root.after(0, lambda: self.update_text_widget(self.text_text, f"\n{error_msg}\n"))
            self.root.after(0, lambda: self.status_var.set(error_msg))

    def update_text_widget(self, text_widget, message):
        text_widget.config(state=tk.NORMAL)
        text_widget.insert(tk.END, message)
        text_widget.see(tk.END)
        text_widget.config(state=tk.DISABLED)

    def update_summary(self, is_malicious, result_text):
        # Check if hash verification indicates a known malicious file
        if "Malicious - Known" in self.hash_verified.get():
            self.result_var.set("MALICIOUS - Known malicious file (Hash verified)")
            self.result_label.configure(style="Malicious.TLabel")
        # Otherwise, use the scan result
        elif is_malicious:
            self.result_var.set("MALICIOUS - File may contain malware")
            self.result_label.configure(style="Malicious.TLabel")
        else:
            # Check if hash is verified as safe
            if self.hash_verified.get() == "Safe - Verified":
                self.result_var.set("SAFE - Verified safe file")
            else:
                self.result_var.set("SAFE - No threats detected")
            self.result_label.configure(style="Safe.TLabel")
        
        # Update details text
        self.details_text.config(state=tk.NORMAL)
        self.details_text.delete(1.0, tk.END)
        self.details_text.insert(tk.END, f"SHA-256: {self.sha256_hash.get()}\n")
        self.details_text.insert(tk.END, f"Verification: {self.hash_verified.get()}\n\n")
        self.details_text.insert(tk.END, result_text)
        self.details_text.config(state=tk.DISABLED)
        
        # Select summary tab
        self.notebook.select(self.summary_frame)
        
        # Update status
        self.status_var.set("Scan completed")

def main():
    root = tk.Tk()
    app = MalwareDetectorApp(root)
    root.mainloop()

if __name__ == "__main__":
    main() 